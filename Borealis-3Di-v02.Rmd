---
title: "Use Case Study - Borealis 3Di"
output: pdf_document
date: "`r Sys.Date()`"
---

<!--
as we sync with Azure/cloud, this doc is in Rmd
-->

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(patchwork)

# functions under development - not yet packaged! ==> source all
my_funs <- list.files(path = "./R", full.names = TRUE)
my_funs |> purrr::map(.f = ~ source(.x))

# set default ggplot theme
ggplot2::theme_set(ggplot2::theme_minimal())
```

# Overview

The 2nd phase of the Borealis 3Di use case analysis aims at studying 3Di parameterisation for a subset of Borealis aerodromes.

# Data Process

## Data Extraction and Preparation

Principal view - refine with developments

* read-in OSN daily dumps and extract trajectories for Borealis aerodrome pairs - under development
  + for the development, we extracted aerodrome pair data with traffic
  + some test data set was produced for 2 aerodrome pairs --> data/bor-dev-...parquet
* extract flights per aerodrome pair
* map flights to NM for RFL (or identify max observed FL)
* establish 3Di milestone table
* calculate score components per flight
  + apply "original" 3Di parameterisation
  + additionally determine flight phase related components
  + ...
* calculate 3Di score per flight
* produce summary stats

## Data Extraction from OSN

Preparatory data extraction - under development - daily downloads - stored in hive / no longer directly available.

A test sample has been extracted from the available state vectors for April 2023.
The samples are stored in ./data/bor-dev-...parquet.

Note: verify timestamps - check, if we saved in CEST or read_parquet adatps timezones!

```{r}
fn <- "./data/bor-dev-egll-eidw.parquet"
ds <- arrow::read_parquet(fn) |> 
  tibble::tibble() |> 
  dplyr::mutate(timestamp = lubridate::with_tz(timestamp, tzone = "UTC"))
```


let's play around with a few trajectories

```{r}
ein151 <- ds |> dplyr::filter(icao24 == "4ca280", substr(day, 1, 10) == "2023-04-01")
```

```{r}
p1 <- ein151 |> 
  ggplot() +
  geom_point(aes(x = longitude, y = latitude, color = callsign))

p2 <- ein151 |> 
  ggplot() +
  geom_point(aes(x = timestamp, y = altitude, color = callsign))

p1 + p2 + plot_layout(guides = "collect") & 
  theme(legend.position = "top")
```

Clean altitude outliers (aka spikes)

```{r}
eins <- ein151 |> mutate(CHECK_ALT = altitude) |> 
  standardise_traj_from_trafficlib() |> 
  alt_outlier_filter() |> 
  identify_trajectory_legs() |> 
  make_uid()
```

```{r}
eins |> 
  ggplot() +
  geom_point(aes(x = TIME, y = FL, color = UID))
```

For this use-case analysis we assume a flight is described by its airborne trajectory, i.e. 
the consecutive points of the same airframe (ICAO24).
We assign an UID per distinct (airborne) portion (leg).

This allows to check for the validity of flight.

* flight (or identified segment[s]) does not start or stop in the air, i.e. departs and lands
* have a duration of more than x minutes


```{r}
prepare_dataset_from_traffic <- function(.ds_tfclib){
  .ds_tfclib |> 
  standardise_traj_from_trafficlib() |> 
  alt_outlier_filter() |> 
  identify_trajectory_legs() |> 
  make_uid()
}

check_valid_trajectory <- function(.trjs){
  valid_trjs <- .trjs |> 
    dplyr::group_by(UID) |> 
    dplyr::summarise(
       EET = difftime(dplyr::last(TIME), dplyr::first(TIME), units = "min")
      ,POS = dplyr::n()
      ,FREQ = mean( STEP[TIME != min(TIME)] )
      ,START_FL = FL[TIME == min(TIME)]
      ,END_FL   = FL[TIME == max(TIME)]
      ) |> 
    # construct validity flag
    dplyr::mutate(VALID = (EET > 10) & (FREQ < 15) & (START_FL < 50) & (END_FL < 50) )
  return(valid_trjs)
}

eins <- ein151 |> 
  prepare_dataset_from_traffic()

eins_valid <- check_valid_trajectory(eins)
eins_valid
```

## calculate airspace intersections

{pruatlas} provides FIR boundaries.

```{r}
borealis_firs <- get_borealis_firs() |> select(ICAO = icao, ID = id, MIN_FL = min_fl, MAX_FL = max_fl, geometry, everything())

borealis_firs |> 
  ggplot() +
  geom_sf()
```

calc airspace crossings

```{r}
inject_airspace_crossings <- function(.trj, .airspace_poly_sf){
  # Load aircraft trajectory data as an sf object, append airspace volumne, and
  # add sequence id
  trj <- .trj |> cast_latlon_to_pts() |> 
    select(FLTID, ICAO24, TIME, LAT, LON, FL) |> 
    sf::st_intersection(.airspace_poly_sf) |> 
    dplyr::mutate(SEQ_ID = dplyr::row_number())
  
  # calculate intersections - heuristic check for change in airspace valume
  # identifying last point before crossing and first point after crossing
  intersections <- trj |> 
    dplyr::filter(
      VOL_AS != dplyr::lead(VOL_AS, default = dplyr::last( VOL_AS)) |
      VOL_AS != dplyr::lag( VOL_AS, default = dplyr::first(VOL_AS))
      ) 
  
  # establish linestrings for successive trajectory points that mark crossing
  # TODO - if point spacing is 1 sec (or < 3), it is save to pick the closest point as approximation
  xpairs <- duplicate_successive_pairs(intersections)
  
  # coerce pairs to linestring and determine intersection points with airspace
  # coerce .airspace_poly_sf to multilinestring
  airspace_mls <- .airspace_poly_sf |> 
    sf::st_cast( "MULTILINESTRING", group_or_split = FALSE)
  # intersect grouped xpairs with airspace_mls
  # add the PREV_SEQ to account for sequence
  # 1. turn pairs into linestring --------------------------------------------
  xpairs_ls <- xpairs |> 
    dplyr::group_by(CROSS) |> #----------- per crossing pair
    dplyr::mutate(PREV_SEQ = dplyr::first(SEQ_ID)) |> 
    dplyr::group_by(CROSS, PREV_SEQ) |> 
    dplyr::group_modify(     # turn successive points into linestring
      .f = ~ cast_latlon_to_ls(.x)
      ,.keep = TRUE    # keep grouping 
    ) |> 
    dplyr::ungroup() |> 
    sf::st_as_sf()          # ensure we have sf object again with attributes
  # 2. calculate intersection with airspace mls ------------------------------
  xpoints <- xpairs_ls |> 
    sf::st_intersection(airspace_mls) |> 
    dplyr::distinct(CROSS, PREV_SEQ, geometry)
  # append LAT LON again and add half-step
  xpoints <- xpoints |> cast_pts_to_latlon(.drop_geometry = FALSE) |> 
    dplyr::mutate(SEQ_ID = PREV_SEQ + 0.5)
  
  # --------------- fill crossing portion ------------------------------------
  # for each crossing point pick PREVIOUS and NEXT from xpairs
  # order and interpolate crossings & fill
  xtripples <- xpairs |> 
    dplyr::bind_rows(xpoints) |> dplyr::arrange(SEQ_ID, CROSS)
  # 1. inject xtimes
  xtripples <- xtripples |> dplyr::group_by(CROSS) |> interpolate_time_df()
  # 2. fill missing bits
  xtripples <- xtripples |> 
    tidyr::fill(FLTID, ICAO24) |> 
    dplyr::mutate(
      VOL_AS = 
            ifelse( is.na(VOL_AS), 
                    paste(dplyr::lag(VOL_AS), dplyr::lead(VOL_AS), sep = "-")
                   ,VOL_AS
                   )
            )
  
  # merge with original trajectory
  # TODO ... think about using rows_update or patch or insert
  trj |> dplyr::bind_rows(xtripples) |> 
    dplyr::arrange(SEQ_ID)
}

#' helper function to replicate rows and filter them, if not successive points
#' The following walks over all previous/next intersection points and creates 
#' previous - next pairs
#' 
duplicate_successive_pairs <- function(.df){
    seq_cross_points <- 1:nrow(.df)
    tmp <- seq_cross_points |> 
      purrr::map_dfr(
        .f = ~ .df |> 
          dplyr::filter(row_number() %in% c(.x, .x+1)) |> 
          dplyr::mutate( CROSS = first(SEQ_ID) == last(SEQ_ID) - 1) |> 
          dplyr::filter(CROSS)
      )
    # add counter for pairs
    tmp <- tmp |> dplyr::mutate(CROSS = rep(1:(nrow(tmp) %/% 2), each = 2))
}

determine_crossing_points <- function(.xpairs, .airspace_mls){
  # spatial operations - turning points to linestring remove attributes
}
```

heuristic
* trajectory is a series of 4D positions
* positions can be associated to an airspace
* if association changes between successive positions, we have a crossing, ELSE NIL

do-if-for-one

```{r}
mik <- eins |> select(UID:LON) |> 
  filter(UID == "4ca280-20230401-0-EIN151") |> 
  inject_airspace_crossings(borealis_firs |> select(ICAO, VOL_AS = ID, geometry))

mik
```

```{}
# do not run this anymore. it only worked for testing multiple crossings and is kept here, for a quick hack to test mutli-airspace crossings during (further) development
mik2 <- mik |> mutate(CROSS = 2)
mik3 <- mik |> mutate(CROSS = 3)
mik  <- bind_rows(mik, mik2, mik3)

bor_firs_ls <- borealis_firs |> select(ICAO, VOL_AS = ID, geometry) |> sf::st_cast( "MULTILINESTRING", group_or_split = FALSE)

mik
```

```{r}
mik2 <- eins |> select(UID:LON) |> 
  group_by(UID) |> 
  group_modify(.f = ~ inject_airspace_crossings(.x, borealis_firs |> select(ICAO, VOL_AS = ID, geometry))
               , .keep = TRUE
               )

mik2
```

```{r}
ggplot() +
  geom_sf(data = borealis_firs |> filter(ID %in% c("EGTTFIR","EISNFIR")), fill = NA) +
  geom_sf(data = mik2 |> sf::st_as_sf(), aes(size = ifelse(nchar(VOL_AS) > 8, 1, 0.1))) +
  coord_sf(xlim = c(-7,1), ylim = c(51,54)) +
  theme(legend.position = "none")
```

calculate for all

```{r}
remove_4D_NAs <- function(.trjs){
  .trjs |> 
    dplyr::filter(!is.na(LAT)) |>     #TODO develop function to fill in first/last misses
    dplyr::filter(!is.na(LON)) |> 
    dplyr::filter(!is.na(FL))
}

ds2 <- ds |> 
  standardise_traj_from_trafficlib() |> 
  remove_4D_NAs() |> 
  alt_outlier_filter() |> 
  identify_trajectory_legs() |> 
  make_uid()
```

As usual moving from a few examples to the whole data set made the loop crash in no time :(

==> with a view to trouble shoot and continue development, use safely()-wrapper.

NOTE: running the following chunk on the complete dataset (all EIDW/EGLL trajectories, 1 sec update)
RUNS FOR ABOUT 20mins on MAC

```{r}
# trouble shoot loop, as it breaks
# use wrapper: safely
# move from group_modify() to group_map() to account for list output
safe_inject_airspace_crossings <- purrr::safely(.f = inject_airspace_crossings, otherwise = data.frame(COMMENT = "ERROR"))


ds3 <- ds2 |> 
  select(UID:LON) |> 
  group_by(UID) |> 
  #group_modify(.f = ~ _inject_airspace_crossings(.x, borealis_firs |> select(ICAO, VOL_AS = ID, geometry))
  group_map(.f = ~ safe_inject_airspace_crossings(.x, borealis_firs |> select(ICAO, VOL_AS = ID, geometry))
                              , .keep = TRUE
               )
```

Exploring the error

```{r}
errors <- map(ds3, "error") 
# force list indices
names(errors) <- seq_along(errors)
# shush away the good stuff (error == NULL)
errors2 <- errors |> discard(is.null)
length(error2)

#saveRDS(errors2, file = "x-error-airspacecrossing.RDS")
```

keep and save the results

```{r}
crunched <- ds3 %>%
     map("result") %>%
     compact() |> 
     bind_rows()

#saveRDS(crunched, "x-crunched-airspacecrossings.RDS")
```

